#Загрузите данные в датафрейм, который назовите data.df.
data.df<-read.table("http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat")

#Сколько строк и столбцов в data.df? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы.
nrow(data.df)
ncol(data.df)

#Получите имена колонок из data.df.
colnames(data.df)

#Найдите значение из 5 строки седьмого столбца.
data.df[5,7]

#Напечатайте целиком 2 строку из data.df
data.df[2,]

#Объясните, что делает следующая строка кода names(data.df) <- c("year", "month", "day", seq(0,23)). 
#Воспользуйтесь функциями head и tail, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?
names(data.df) <- c("year", "month", "day", seq(0,23)) #дает столбцам датафрейма имена
head(data.df, 1) #Последние 24 колонки с названиями от 0 до 23 содержат нули

#Добавьте новую колонку с названием daily, в которую запишите сумму крайних правых 24 колонок. 
#Постройте гистограмму по этой колонке. Какие выводы можно сделать?

data.df$daily<-apply(data.df[,4:27], 1, sum)
hist(data.df$daily, prob = TRUE, main = "Гистограмма частоты количества осадков",
     sub = "Количество осадков за день")
#Поскольку в гистограмме есть отрицательные значения на оси абцисс, часть исходных данных повреждена

#Создайте новый датафрейм fixed.df в котром исправьте замеченную ошибку. 
#Постройте новую гистограмму, поясните почему она более корректна.
fixed.df<-data.df
for (i in 1:nrow(fixed.df)){
  for (j in 1:ncol(fixed.df))
  {
    if (data.df[i,j] < 0)
    {
      data.df[i,j]<-0
    }
  }
}

daily<-apply(fixed.df[,4:27], 1, sum)
names(fixed.df) <- c("year", "month", "day", seq(0,23), "daily")

hist(fixed.df$daily, prob = TRUE, main = "Гистограмма частоты количества осадков",
     sub = "Количество осадков за день")
#Полученная гистограмма более корректна, поскольку в ней нет отрицательных значений количества осадков за день.



#Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.
#v <- c("4", "8", "15", "16", "23", "42")
#max(v) считает максимальное значение вектора, символ "8" элемента вектора "8" имеет максимальное значение в кодировке
#sort(v) сортирует строковые элементы по возрастанию значения кодировки 1 символа строк вектора, если значения одинаковы, сравнение по 2 символу и т. д.
#sum(v) ошибка: функция не может работать с типом аргумента - "символ", вектор v состоит из символов

#Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.
#v2 <- c("5",7,12)
#v2[2] + 2[3] не может сложить число(2 элемент вектора) с нечислом

#df3 <- data.frame(z1="5",z2=7,z3=12)
#df3[1,2] + df3[1,3] складывает 2 и 3 элемент датафрейма

#l4 <- list(z1="6", z2=42, z3="49", z4=126)
#l4[[2]] + l4[[4]] склдадывает значения элементов 2 и 4 компонентов списка
#l4[2] + l4[4] не может сложить 2(z2) и 4(z4) компоненты списка




#Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции seq(), которую вы использовали раньше. Изучите эту функцию, вызвав команду ?seq. Испольуя полученные знания выведите на экран:
#Числа от 1 до 10000 с инкрементом 372:
seq(1, 10000, 372)

#Числа от 1 до 10000 длиной 50:
seq(1, 10000, length.out = 50)

#Функция rep() повторяет переданный вектор указанное число раз. Объясните разницу между rep(1:5,times=3) и rep(1:5, each=3).
rep(1:5,times=3) #повторяет весь вектор 3 раза подряд
rep(1:5, each=3) #повторяет каждый элемент вектора 3 раза подряд
